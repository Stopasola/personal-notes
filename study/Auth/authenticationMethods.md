#### 1. Authentication

##### 1.1 Basic Auth

Checks for valid credentials in the Proxy-Authorization and Authorization headers. Basic Authentication is a simple authentication scheme used to protect resources over HTTP. It involves sending the username and password as part of the request's authorization header. Despite its simplicity, it is not recommended for sensitive applications as the credentials are sent in plaintext, which can be easily intercepted and decoded.

A Basic Authentication header looks like this:

>> Authorization: Basic base64(username:password)


```javascript
url = "https://api.example.com/data"
username = "your_username"
password = "your_password"

response = requests.get(url, auth=HTTPBasicAuth(username, password))
```
Remember that Basic Authentication is not the most secure option, especially if used without HTTPS. Consider using more robust authentication methods like OAuth or JWT for more sensitive applications.

##### 1.2 JWT (JSON Web Token)

Widely used authentication method for securing web applications and APIs. It is a compact and self-contained way of representing information between two parties, typically used to authenticate users and transmit information securely. A JWT consists of three parts:

- Header: Information about the token.
- Payload: User data.
- Signature: Verify integrity of the token.

#### Generate jwt token

```javascript
const jwt = require('jsonwebtoken');

const secretkey = 'secret key'
const userData = {
  username: 'example',
  isAdmin: true,
}

const token = jwt.sign(userData, secretkey, { expiresIn: '1h' })
console.log('JWT Token:', token);
```

In this example, we use the `jwt.sign` method to create a JWT token. The `userData` object contains the claims we want to include in the token, and the `secretKey` is a private key used to sign the token. 

##### Verify and decode the JWT

```javascript
const decodedToken = jwt.verify(token, secretKey);
console.log('Decoded Token:', decodedToken);
```


##### Portect a route with jwt


```javascript
const app = express();
const jwt = require('jsonwebtoken');


function authtoken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && autHeader.split(' ')[1]

  if(!token) {
    return res.sendStatus(401);
  }

  jwt.verify(token, secretKey, (err, user) => {
    if (err) {
      return res.sendStatus(403);
    }
    req.user = user;
    next();
  });
}


app.get('/protected', authtoken, (req, res) => {
  res.json({ message: 'You are authorized to access this route.' })
})

app.listen(3000, () => {
  console.log('Server is running on port 3000.');
})
```
JWT is commonly used for securing APIs, providing Single Sign-On (SSO) functionality, and token-based authentication. However, remember to keep the secretKey safe and don't include sensitive information in the token's payload. Also, consider using HTTPS to ensure secure transmission of JWT tokens.

##### 1.3 API Keys

In the context of key-based authentication, a unique key is generated by the server and shared with the client. This key acts as a secret that only authorized parties possess, ensuring secure communication and authentication.

When a client sends a request to the server, it includes the key as part of the request header or parameters. The server then validates the key against its stored list of valid keys. If the key matches, the server grants access to the requested resource or operation; otherwise, it denies access.

Once you have generated the API key, you can store it securely in your server-side environment or database. When a client wants to access your protected resources, they should include the API key in their requests, and the server will then validate it against its stored list of valid keys before granting access

Regularly rotate keys, implement rate limiting, and consider additional security measures, such as IP whitelisting, to enhance the security of your key-based authentication system.


###### Key-based authentication

```javascript
const express = require('express');
const app = express();
const crypto = require('crypto');

function generateApiKey() {
  return crypto.randomBytes(32).toString('hex');
}

const API_KEY = generateApiKey();

// Middleware to check the API key
function authenticateKey(req, res, next) {
  
  const apiKey = req.headers['x-api-key'];

  if (!apiKey || apiKey !== API_KEY) {
    return res.sendStatus(401);
  }

  next();
}

// Protected route
app.get('/protected', authenticateKey, (req, res) => {
  res.json({ message: 'You are authorized to access this route.' });
});

app.listen(3000, () => {
  console.log('Server is running on port 3000.');
});
```


#### 1.3 OAuth2 



OAuth 2.0 (Open Authorization 2.0) is an authorization framework that allows third-party applications to access protected resources on behalf of a user, without needing to know their credentials (e.g., username and password). It is widely used to enable secure and delegated access to APIs and services. OAuth 2.0 provides different grant types for different use cases, such as web applications, mobile applications, and server-to-server communication. It is commoly used on APIs auth.

- Resource owner: entity that grants access to your data. **Owner of the resource**, it is how the OAuth2 classificates the user.
- Client:  App tha interacts with the resource owner. In the case of an web app, it would be the browser app.
- Resource Server: APIs exposed on the internet and needs data protection.
- Authorization Server: Responsible to auth the server, and gives the access tokens. Have the Resource owner data.


#### Sep by Step Approach

1. Client Registration: The client application (third-party application) registers with the authorization server (usually the service provider) and receives a client ID and client secret.Register your data on the service, this step is mandatory before use OAuth. First you need assing to a form with multiple information, for example: 

- URL de callback/URL de retorno: addres where you will receive answers of specific events. It is used to an app send data to another service,  allowing communication.

**Step1:** Register your application on GitHub Developer Settings to obtain a client ID and client secret.

2. Authorization Request: The client initiates the authorization process by redirecting the user to the authorization server's authorization endpoint. The client includes its client ID, requested scope (the permissions it needs), and a redirect URI.

**Step2:** Redirect the user to GitHub's authorization endpoint for user consent.

`https://github.com/login/oauth/authorize?client_id=YOUR_CLIENT_ID&redirect_uri=YOUR_REDIRECT_URI&scope=repo`

3. User Consent: At the authorization endpoint, the user is presented with a consent screen where they can review the permissions requested by the client and decide whether to grant access.

**Step3:** The user will be presented with GitHub's consent screen.

4. Authorization Grant: If the user grants access, the authorization server issues an authorization grant to the client. 

**Step4:** Upon user consent, GitHub will redirect the user back to your redirect URI with an authorization code as a query parameter.

5. Token Request: The client exchanges the authorization grant for an access token by making a token request to the token endpoint of the authorization server. The access token is a short-lived credential that represents the client's authority to access the protected resources. Here is when you will receive an refresh_token, this will generate an access_token every time the last one is expired.

**Step5:** Exchange the authorization code for an access token using the token endpoint.

6. Accessing Protected Resources: The client includes the access token in its API requests as an authorization header, allowing the server to verify the token and grant access to the requested resources.

Exercise: Code this process step by step. 

#### Notes:

**State:** parameter helps ensure the integrity of the authorization process and prevents attackers from forging legitimate authorization requests using unauthorized user sessions. It's an important security measure to include in your OAuth2 implementation.

**Bearer:** The term "Bearer" indicates that the token itself is the only thing needed to authenticate the request, much like if you were to "bear" a ticket to access a show. The server trusts the token and the credentials it represents without the need for additional credentials or information.

It's important to use HTTPS when transmitting bearer tokens to ensure their security since they grant access to protected resources. Additionally, bearer tokens should be kept confidential and not exposed to unauthorized users.

In summary, "Bearer" is a way to convey that an access token should be presented directly to access a resource, without requiring additional credentials. It's a common authentication mechanism used in OAuth 2.0 and JWT-based systems.


**JWT Vs OAuth2** OAuth 2.0 and JWT (JSON Web Tokens) are related concepts, but they are not the same thing. OAuth 2.0 is an authorization framework that defines how third-party applications can gain limited access to a user's resources on a resource server (often an API) on their behalf. JWT, on the other hand, is a specific format for encoding claims securely between two parties.
To summarize, OAuth 2.0 is a broader authorization framework that defines how permissions are granted to third-party applications. JWT is a specific token format used in various contexts, including OAuth 2.0, for transmitting claims securely between parties.


### [OAuth2 Implementation](https://replit.com/join/tcdplhdjgo-fernandostopaso) 






